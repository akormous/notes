"use strict";(self.webpackChunkmy_notes=self.webpackChunkmy_notes||[]).push([[6628],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>k});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=p(a),h=i,k=u["".concat(s,".").concat(h)]||u[h]||m[h]||l;return a?n.createElement(k,r(r({ref:t},d),{},{components:a})):n.createElement(k,r({ref:t},d))}));function k(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=a.length,r=new Array(l);r[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:i,r[1]=o;for(var p=2;p<l;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},1903:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const l={},r="Trees and Graphs",o={unversionedId:"dsa/TreesAndGraphs",id:"dsa/TreesAndGraphs",title:"Trees and Graphs",description:"DISCLAIMER: If you don't know what a tree is, don't read the rest of this page.",source:"@site/docs/2-dsa/TreesAndGraphs.md",sourceDirName:"2-dsa",slug:"/dsa/TreesAndGraphs",permalink:"/notes/docs/dsa/TreesAndGraphs",draft:!1,editUrl:"https://github.com/akormous/notes/edit/master/docs/2-dsa/TreesAndGraphs.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Sorting Algorithms",permalink:"/notes/docs/dsa/SortingAlgorithms"},next:{title:"Docker and Kubernetes",permalink:"/notes/docs/docker-kubernetes/"}},s={},p=[{value:"Binary Heaps",id:"binary-heaps",level:2},{value:"Tries",id:"tries",level:2},{value:"Introduction to Fenwick and Segment Trees",id:"introduction-to-fenwick-and-segment-trees",level:2},{value:"Segment Tree",id:"segment-tree",level:2},{value:"Fenwick Tree / Binary Indexed Tree",id:"fenwick-tree--binary-indexed-tree",level:2},{value:"Theory",id:"theory",level:2},{value:"Depth-first Search",id:"depth-first-search",level:2},{value:"Breadth-first Search",id:"breadth-first-search",level:2},{value:"Topological Sort",id:"topological-sort",level:2},{value:"Single-Source Shortest Path in a DAG",id:"single-source-shortest-path-in-a-dag",level:2},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:2},{value:"Bellman-Ford Algorithm",id:"bellman-ford-algorithm",level:2},{value:"Floyd-Warshall Algorithm",id:"floyd-warshall-algorithm",level:2},{value:"Bridge",id:"bridge",level:2},{value:"Articulation point",id:"articulation-point",level:2},{value:"Significance of bridges and articulation points",id:"significance-of-bridges-and-articulation-points",level:2},{value:"Low-link value",id:"low-link-value",level:2},{value:"Tarjans Algorithm for finding bridges",id:"tarjans-algorithm-for-finding-bridges",level:2},{value:"Eulerian Path",id:"eulerian-path",level:2},{value:"Eulerian Circuit",id:"eulerian-circuit",level:2},{value:"What condition are required for a valid Eulerian Path/Circuit?",id:"what-condition-are-required-for-a-valid-eulerian-pathcircuit",level:2}],d={toc:p};function u(e){let{components:t,...l}=e;return(0,i.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"trees-and-graphs"},"Trees and Graphs"),(0,i.kt)("p",null,"DISCLAIMER: If you don't know what a tree is, don't read the rest of this page."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"A Binary Tree is a Tree, but a Tree is not a Binary Tree")," - ",(0,i.kt)("strong",{parentName:"p"},"Barack Obama")),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"trees"},"Trees"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Binary Tree"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each node has at most 2 children"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Binary Search Tree"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is a binary tree but follows a simple rule"),(0,i.kt)("li",{parentName:"ul"},"\ud83d\udd37 all left descendants <= the node <  all right descendants \ud83d\udd36 "),(0,i.kt)("li",{parentName:"ul"},"The equality can appear on the left or right side, depends on the situation"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Complete Binary Tree"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Binary Tree in which every level is fully filled, except for the last level"),(0,i.kt)("li",{parentName:"ul"},"The last level is filled from left to right"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Full Binary Tree"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Binary Tree in which every node has either 0 or 2 child nodes"),(0,i.kt)("li",{parentName:"ul"},"\u2757 None of the node has 1 child"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Perfect Binary Tree"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Binary Tree"),(0,i.kt)("li",{parentName:"ul"},"which is Complete and Full")),(0,i.kt)("p",null,"\u2b50 It has 2",(0,i.kt)("sup",null,"k")," - 1 nodes, where k = number of levels in the tree")),(0,i.kt)("h2",{id:"binary-heaps"},"Binary Heaps"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Advantages of Heap over Array"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"O(logn) to insert in heap, but O(n) to insert in sorted array"),(0,i.kt)("li",{parentName:"ul"},"O(logn) to extract min / max from heap, but O(n) in array"),(0,i.kt)("li",{parentName:"ul"},"O(1) to find min / max from heap, but O(n) in array"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Min-heap"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A min-heap is a ",(0,i.kt)("em",{parentName:"li"},"complete")," binary tree, where each node is smaller than its children"),(0,i.kt)("li",{parentName:"ul"},"The root is the minimum element in the tree"),(0,i.kt)("li",{parentName:"ul"},"There are 2 key operations on min-heap ",(0,i.kt)("inlineCode",{parentName:"li"},"insert")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"extract_min")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/akormous/dsa/tree/master/0_Basics/MinHeap.cpp"},"Min Heap Implementation"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"insert")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Insert the new element at the bottomost rightmost spot (as to maintain the complete binary tree property)"),(0,i.kt)("li",{parentName:"ul"},"Fix the tree by swapping the new value with its parent till an appropriate spot is found"),(0,i.kt)("li",{parentName:"ul"},"Time Complexity - O(logn)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"extract_min")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace the minimum element at the top with the bottommost rightmost element"),(0,i.kt)("li",{parentName:"ul"},"Fix the tree by swapping this value with one of the children till the min-heap property is restored"),(0,i.kt)("li",{parentName:"ul"},"Time Complexity - O(logn)"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Max-heap"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A max-heap is a ",(0,i.kt)("em",{parentName:"li"},"complete")," binary tree, where each node is larger than its children"),(0,i.kt)("li",{parentName:"ul"},"The root is the maximum element in the tree"),(0,i.kt)("li",{parentName:"ul"},"There are 2 key operations on max-heap ",(0,i.kt)("inlineCode",{parentName:"li"},"insert")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"extract_max")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/akormous/dsa/tree/master/0_Basics/MaxHeap.cpp"},"Max Heap Implementation"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"insert")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Insert the new element at the bottomost rightmost spot (as to maintain the complete binary tree property)"),(0,i.kt)("li",{parentName:"ul"},"Fix the tree by swapping the new value with its parent till an appropriate spot is found"),(0,i.kt)("li",{parentName:"ul"},"Time Complexity - O(logn)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"extract_max")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Replace the maximum element at the top with the bottommost rightmost element"),(0,i.kt)("li",{parentName:"ul"},"Fix the tree by swapping this value with one of the children till the max-heap property is restored"),(0,i.kt)("li",{parentName:"ul"},"Time Complexity - O(logn)"))),(0,i.kt)("h2",{id:"tries"},"Tries"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"What is a Trie ?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"aka Prefix Tree"),(0,i.kt)("li",{parentName:"ul"},"It is a type of a search tree"),(0,i.kt)("li",{parentName:"ul"},"A trie is an ",(0,i.kt)("em",{parentName:"li"},"n-ary")," tree in which characters are stored at each node"),(0,i.kt)("li",{parentName:"ul"},"Words can be re ",(0,i.kt)("em",{parentName:"li"},"trie")," ved by traversing down a branch"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Structure"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Each trie has an empty root node, with links to other nodes - one for each possible alphabetic value")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Each node contains an array of pointers to child nodes - one for each possible alphabetic value")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"\u2757NOTE - The size of the trie is directly correlated to the size of the alphabet being represented by the data structure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Every node in trie (including the root node) at least has these 2 aspects"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A value, which might be NULL"),(0,i.kt)("li",{parentName:"ul"},"An array of reference to child nodes which also might be NULL"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/tree/master/0_Basics/Trie.cpp"},"Trie Implementation")))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Trie",src:a(4913).Z,title:"Trie Data Structure Example",width:"1321",height:"1071"}))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"introduction-to-fenwick-and-segment-trees"},"Introduction to Fenwick and Segment Trees"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Consider an ",(0,i.kt)("inlineCode",{parentName:"li"},"arr[0 ... n-1]")),(0,i.kt)("li",{parentName:"ul"},"We want to do 2 operations on this array",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Compute the sum of first ",(0,i.kt)("em",{parentName:"li"},"i")," elements"),(0,i.kt)("li",{parentName:"ul"},"Modify the value of a specified element ",(0,i.kt)("inlineCode",{parentName:"li"},"arr[i] = x")," where ",(0,i.kt)("inlineCode",{parentName:"li"},"0 <= i <= n-1")))),(0,i.kt)("li",{parentName:"ul"},"Simple solution is to run a loop for calculating sum ",(0,i.kt)("inlineCode",{parentName:"li"},"O(n)")," and modify value by simple indexing, so ",(0,i.kt)("inlineCode",{parentName:"li"},"O(1)")),(0,i.kt)("li",{parentName:"ul"},"What if we want to perform both operations in ",(0,i.kt)("inlineCode",{parentName:"li"},"O(logn)")),(0,i.kt)("li",{parentName:"ul"},"Recommended reading: Efficient Bit Operations"),(0,i.kt)("li",{parentName:"ul"},"Continue reading")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"segment-tree"},"Segment Tree"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"To be updated")),(0,i.kt)("h2",{id:"fenwick-tree--binary-indexed-tree"},"Fenwick Tree / Binary Indexed Tree"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Representation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is represented as an array"),(0,i.kt)("li",{parentName:"ul"},"Let the array be ",(0,i.kt)("inlineCode",{parentName:"li"},"BITree[]")),(0,i.kt)("li",{parentName:"ul"},"The size of the Binary Indexed tree is equal to the size of input array"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Construction"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Initialize the ",(0,i.kt)("inlineCode",{parentName:"li"},"BITree[]")," as 0"),(0,i.kt)("li",{parentName:"ul"},"Then we call ",(0,i.kt)("inlineCode",{parentName:"li"},"update()")," for all the indexes"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Operations"),(0,i.kt)("p",null,"There are 2 operations"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"getSum(x)")," - Returns the sum of the subarray ",(0,i.kt)("inlineCode",{parentName:"li"},"arr[0 ... x]"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"- Initialize the output `sum` as `0`, the current index as `x + 1`\n- Do following while the current index is greater than `0`\n    - Add `BITree[index]` to `sum`\n    - Go to the parent of `index`\n        - How to go to the parent ? By removing the right most set bit\n        - `index` = `index - (index & (-index))`\n- Return `sum`\n")),(0,i.kt)("img",{alt:"Fenwick getSum()",src:a(5937).Z,title:"Fenwick getSum()",width:"810",height:"614"})),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"update(x, val)")," - Update the Binary Indexed Tree by performing ",(0,i.kt)("inlineCode",{parentName:"li"},"arr[index] += val"),", it will make changes to ",(0,i.kt)("inlineCode",{parentName:"li"},"BITree[]"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"- Initialize current index as `x + 1`\n- Do the following while the current index is smaller than or equal to `n`\n    - Add the `val` to `BITree[index]`\n    - Go to the next element of `BITree[index]`\n        - The next element can be obtained by incrementing the last set bit of the current index\n        - `index = index + (index & (-index))`\n")),(0,i.kt)("img",{alt:"Fenwick update()",src:a(7197).Z,title:"Fenwick update()",width:"758",height:"693"})))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Applications"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To get prefix sum of an array in ",(0,i.kt)("inlineCode",{parentName:"li"},"O(logn)")," time"),(0,i.kt)("li",{parentName:"ul"},"To update the prefix sum array in ",(0,i.kt)("inlineCode",{parentName:"li"},"O(logn)")," time"))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/5_Trees_and_Graphs/FenwickTree.cpp"},"Fenwick Tree Implementation")),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"A tree is actually a type of graph, but not all graphs are trees")," - ",(0,i.kt)("strong",{parentName:"p"},"Doge")),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"graphs"},"Graphs"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A tree is a connected graph without cycles."),(0,i.kt)("li",{parentName:"ul"},"A graph is a collection of nodes with edges between them")),(0,i.kt)("h2",{id:"theory"},"Theory"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Directed and Undirected"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Directed edge, one way"),(0,i.kt)("li",{parentName:"ul"},"Undirected edge, two way")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Directed and Undirected",src:a(6270).Z,title:"Directed and Undirected",width:"1033",height:"475"}))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Weighted"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Every edge has a weight assigned to it")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Weighted",src:a(7520).Z,title:"Weighted Graph",width:"890",height:"627"}))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Rooted Tree"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is a tree with a ",(0,i.kt)("strong",{parentName:"li"},"designated root node")),(0,i.kt)("li",{parentName:"ul"},"Every edge either points away from or towards the root node"),(0,i.kt)("li",{parentName:"ul"},"When edges point away from the root -> ",(0,i.kt)("strong",{parentName:"li"},"arborescence")," (out-tree)"),(0,i.kt)("li",{parentName:"ul"},"When edges point away from the root -> ",(0,i.kt)("strong",{parentName:"li"},"anti-arborescence")," (in-tree)")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Rooted Trees",src:a(1312).Z,title:"Rooted Trees",width:"1583",height:"566"}))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Connected and Disconnected"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If there is a path from any point to any other point in the graph, it is called a connected graph"),(0,i.kt)("li",{parentName:"ul"},"If there exists multiple disconnected vertices and edges, then it is called a disconnected graph")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Connected and Disconneted",src:a(9359).Z,title:"Connected and Disconnected",width:"967",height:"397"}))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Cyclic and Acyclic"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If a graph contains cycles, then it is called a cyclic graph"),(0,i.kt)("li",{parentName:"ul"},"A graph containing 0 cycles is an acyclic graph")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Cyclic Acyclic",src:a(3914).Z,title:"Cyclic Acyclic",width:"596",height:"288"}))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Directed Acyclic Graph (DAGs)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Directed graphs with no cycles")),(0,i.kt)("li",{parentName:"ul"},"These graphs play an important role in representing structures with dependencies"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Bipartite Graph"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("strong",{parentName:"li"},"bipartite graph")," is one whose vertices can be split into two independent groups U, V such that every edge connects between U and V")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Bipartite",src:a(5642).Z,title:"Bipartite",width:"1084",height:"464"}))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Strongly Connected Components"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SCCs can be thought of as self-contained cycles within a directed graph where every vertex in a given cycle can reach every other vertex in the same cycle")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"SCCs",src:a(1622).Z,title:"SCCs",width:"974",height:"382"}))),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"algorithms"},"Algorithms"),(0,i.kt)("h2",{id:"depth-first-search"},"Depth-first Search"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/DFS.cpp"},"DFS code")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"What can DFS do?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Compute a graph's minimum spanning tree"),(0,i.kt)("li",{parentName:"ul"},"Detect and find cycles in a graph"),(0,i.kt)("li",{parentName:"ul"},"Check if a graph is bipartite"),(0,i.kt)("li",{parentName:"ul"},"Find strongly connected components"),(0,i.kt)("li",{parentName:"ul"},"Topologically sort the nodes of a graph"),(0,i.kt)("li",{parentName:"ul"},"Find bridges and articulation points"),(0,i.kt)("li",{parentName:"ul"},"Find augmenting paths in a flow network"),(0,i.kt)("li",{parentName:"ul"},"Generate mazes"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Time Complexity"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"O(V + E)"))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"breadth-first-search"},"Breadth-first Search"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/BFS.cpp"},"BFS code")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"What can BFS do?"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Find shortest path on unweighted graph"),(0,i.kt)("li",{parentName:"ul"},"Number of Islands in a grid, quite popular problem"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Time Complexity"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"O(V + E)"))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"topological-sort"},"Topological Sort"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/TopologicalSort.cpp"},"Topological Sort Code")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It is only for Directed Acyclic Graphs (DAG)"),(0,i.kt)("li",{parentName:"ul"},"It is a linear ordering of vertices such that for every directed edge ",(0,i.kt)("em",{parentName:"li"},"(u,v)")," , vertex ",(0,i.kt)("em",{parentName:"li"},"u")," comes before ",(0,i.kt)("em",{parentName:"li"},"v")," in the ordering"),(0,i.kt)("li",{parentName:"ul"},"Time Complexity = ",(0,i.kt)("inlineCode",{parentName:"li"},"O(V + E)"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Applications"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"School class prerequisites"),(0,i.kt)("li",{parentName:"ul"},"Program dependencies"),(0,i.kt)("li",{parentName:"ul"},"Event Scheduling"),(0,i.kt)("li",{parentName:"ul"},"Assembly Instructions"))),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"single-source-shortest-path-in-a-dag"},"Single-Source Shortest Path in a DAG"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/ShortestPathDAG.cpp"},"SSSPDAG Code")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Popular application of Topological Sort"),(0,i.kt)("li",{parentName:"ul"},"Find the shortest path from one given source node to every other node in the graph"),(0,i.kt)("li",{parentName:"ul"},"Only valid for DAGs though")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"dijkstras-algorithm"},"Dijkstra's Algorithm"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/DijkstrasAlgorithm.cpp"},"Dijkstra's Code")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Maintain a 'dist' array where the distance to every node is +ve infinity. Mark the distance to the start node 's' to be 0."),(0,i.kt)("li",{parentName:"ul"},"Maintain a PQ of key-value pairs of (node_index, distance) pairs which tell you which node to visit next based on sorted min value."),(0,i.kt)("li",{parentName:"ul"},"Insert (s,0) into the PQ and loop while PQ is not empty pulling out the next most promising (node_index, distance) pair."),(0,i.kt)("li",{parentName:"ul"},"Iterate over all edges outwards from the current node and relax each edge appending a new (node_index, distance) key-value pair to the PQ for every relaxation."))),(0,i.kt)("hr",null),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SSSP Algorithm for graphs with ",(0,i.kt)("strong",{parentName:"li"},"non-negative edge weights")),(0,i.kt)("li",{parentName:"ul"},"Time Complexity = ",(0,i.kt)("inlineCode",{parentName:"li"},"O(E * log(V))")),(0,i.kt)("li",{parentName:"ul"},"\u26a0\ufe0f NOTE: One constraint for Dijkstra's algorithm is that the graph must contain ",(0,i.kt)("strong",{parentName:"li"},"non-negative edge weights"),"."),(0,i.kt)("li",{parentName:"ul"},"This constraint is imposed to ensure that once a node has been visited its optimal distance cannot be improved"),(0,i.kt)("li",{parentName:"ul"},"This property enables Dijkstra's algorithm to act in a greedy manner by always selecting the next most promising node")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"bellman-ford-algorithm"},"Bellman-Ford Algorithm"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/BellmanFord.cpp"},"Bellman-Ford code")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"v = number of nodes in the graph"),(0,i.kt)("li",{parentName:"ul"},"e = number of edges in the graph"),(0,i.kt)("li",{parentName:"ul"},"s = starting node"),(0,i.kt)("li",{parentName:"ul"},"dist[] = distance to each node from 's'"),(0,i.kt)("li",{parentName:"ul"},"Maintain a 'dist' array of size v, initially the distance to each node is +ve infinity"),(0,i.kt)("li",{parentName:"ul"},"Set the distance to starting node as 0"),(0,i.kt)("li",{parentName:"ul"},"Relax each edge v-1 times"),(0,i.kt)("li",{parentName:"ul"},"Why v-1 times? Because we don't know the sequence in which the edges will be processed, since the longest path can be v-1 nodes long, to consider all the edges we run it v-1 times."),(0,i.kt)("li",{parentName:"ul"},"For more clarification ",(0,i.kt)("a",{parentName:"li",href:"https://riptutorial.com/algorithm/example/24029/why-do-we-need-to-relax-all-the-edges-at-most--v-1--times"},"Why do we need to relax all the edges v-1 times in Bellman-Ford?")))),(0,i.kt)("hr",null),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SSSP algorithm that can ",(0,i.kt)("strong",{parentName:"li"},"detect negative cycles")),(0,i.kt)("li",{parentName:"ul"},"Time Complexity - ",(0,i.kt)("inlineCode",{parentName:"li"},"O(EV)")),(0,i.kt)("li",{parentName:"ul"},"When to use? When the graph has negative cycles because Dijkstra's can't handle negative edge weights")),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"floyd-warshall-algorithm"},"Floyd-Warshall Algorithm"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/FloydWarshall.cpp"},"Floyd-Warshall code")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Algorithm"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The Memo Table: it will be 3-D matrix ",(0,i.kt)("inlineCode",{parentName:"li"},"dp[k][i][j]")),(0,i.kt)("li",{parentName:"ul"},"which stores shortest path from ",(0,i.kt)("inlineCode",{parentName:"li"},"i")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"j")," routing through ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," nodes"),(0,i.kt)("li",{parentName:"ul"},"specifically, ",(0,i.kt)("inlineCode",{parentName:"li"},"dp[n-1]")," is the 2-D matrix solution we are looking for"),(0,i.kt)("li",{parentName:"ul"},"when ",(0,i.kt)("inlineCode",{parentName:"li"},"k = 0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"dp[0][i][j] = adj[i][j]")),(0,i.kt)("li",{parentName:"ul"},"otherwise, ",(0,i.kt)("inlineCode",{parentName:"li"},"dp[k][i][j] = min(dp[k-1][i][j], dp[k-1][i][k] + dp[k-1][k][j])")),(0,i.kt)("li",{parentName:"ul"},"we can convert memo table to 2-D, by changing the values in place, rather than storing the state ",(0,i.kt)("inlineCode",{parentName:"li"},"k-1")),(0,i.kt)("li",{parentName:"ul"},"so it reduces to, when ",(0,i.kt)("inlineCode",{parentName:"li"},"k = 0"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"dp[i][j] = adj[i][j]")),(0,i.kt)("li",{parentName:"ul"},"otherwise, ",(0,i.kt)("inlineCode",{parentName:"li"},"dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])")))),(0,i.kt)("hr",null),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"This is an all-pairs shortest path algorithm."),(0,i.kt)("li",{parentName:"ul"},"It finds the shortest distance between all pairs of nodes"),(0,i.kt)("li",{parentName:"ul"},"Time Complexity - ",(0,i.kt)("inlineCode",{parentName:"li"},"O(V^3)")),(0,i.kt)("li",{parentName:"ul"},"ideal for graphs no larger than a couple of hundred nodes"),(0,i.kt)("li",{parentName:"ul"},"it can detect negative cycles")),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"bridges-and-articulation-points"},"Bridges and Articulation Points"),(0,i.kt)("h2",{id:"bridge"},"Bridge"),(0,i.kt)("p",null,"A bridge/cut edge is any ",(0,i.kt)("strong",{parentName:"p"},"edge")," in a graph whose removal increases the number of connected components"),(0,i.kt)("h2",{id:"articulation-point"},"Articulation point"),(0,i.kt)("p",null,"An articulation point/cut vertex is any ",(0,i.kt)("strong",{parentName:"p"},"node")," in a graph whose removal increases the number of connected components"),(0,i.kt)("mermaid",{value:"flowchart LR\nnode0((0))\nnode1((1))\nnode2((2))\nnode3((3))\nnode4((4))\nnode5((5))\nnode6((6))\nnode7((7))\nnode8((8))\n\nnode0 --- node1\nnode0 --- node2\nnode1 --- node2\nnode2 --- node3\nnode3 --- node4\nnode2 --- node5\nnode5 --- node6\nnode5 --- node8\nnode6 --- node7\nnode7 --- node8"}),(0,i.kt)("p",null,"In the above graph\n",(0,i.kt)("em",{parentName:"p"},"Bridges - {2,3}, {3,4}, {2,5}")," and\n",(0,i.kt)("em",{parentName:"p"},"Articulation points - {2}, {5}, {3}")),(0,i.kt)("h2",{id:"significance-of-bridges-and-articulation-points"},"Significance of bridges and articulation points"),(0,i.kt)("p",null,"Bridges and articulation points are important because they often hint at ",(0,i.kt)("em",{parentName:"p"},"weak points"),", ",(0,i.kt)("em",{parentName:"p"},"bottlenecks")," or ",(0,i.kt)("em",{parentName:"p"},"vulnerabilities")," in a graph. Therefore it is important to be able to quickly find/detect when and where these occur."),(0,i.kt)("h2",{id:"low-link-value"},"Low-link value"),(0,i.kt)("p",null,"The low-link value of a node is the smallest (lowest) id reachable from that node when doing a DFS (including itself)"),(0,i.kt)("h2",{id:"tarjans-algorithm-for-finding-bridges"},"Tarjans Algorithm for finding bridges"),(0,i.kt)("p",null,"Code - ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/FindBridgesInAGraph.cpp"},"Find Bridges")),(0,i.kt)("hr",null),(0,i.kt)("h1",{id:"eulerian-path-and-circuit"},"Eulerian Path and Circuit"),(0,i.kt)("h2",{id:"eulerian-path"},"Eulerian Path"),(0,i.kt)("p",null,"An Eulerian Path is a path of edges that visits all the edges in a graph exactly once."),(0,i.kt)("h2",{id:"eulerian-circuit"},"Eulerian Circuit"),(0,i.kt)("p",null,"An Eulerian Circuit is an Eulerian Path which starts and ends on the same vertex."),(0,i.kt)("h2",{id:"what-condition-are-required-for-a-valid-eulerian-pathcircuit"},"What condition are required for a valid Eulerian Path/Circuit?"),(0,i.kt)("p",null,"Depends on the kind of graph:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Undirected Graph"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Eulerian Circuit")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Every vertex has an even degree")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Eulerian Path")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Either every vertex has even degree "),(0,i.kt)("li",{parentName:"ul"},"Or exactly 2 vertices have odd degrees"))),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Directed Graph"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Eulerian Circuit")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Every vertex has ",(0,i.kt)("strong",{parentName:"li"},"equal")," indegree and outdegree")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Eulerian Path")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"At most 1 vertex has ",(0,i.kt)("inlineCode",{parentName:"li"},"(outDegree - inDegree) = 1")," and at most 1 vertex has ",(0,i.kt)("inlineCode",{parentName:"li"},"(inDegree - outDegree) = 1")," and all other vertices have equal in and out degrees"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Finding an Eulerian Path - Time Complexity - ",(0,i.kt)("inlineCode",{parentName:"strong"},"O(E)"))),(0,i.kt)("p",null,"Code - ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/akormous/dsa/blob/master/0_Basics/Trees_and_Graphs/EulerianPath.cpp"},"Reconstruct Itinerary LC332")))}u.isMDXComponent=!0},5642:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/BipartiteGraph-97c402b4982d1c11acf2e6c3d6703a1e.png"},9359:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/ConnectedAndDisconnectedGraph-d43ece9ff811215bf2da6bf935623bc9.png"},3914:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/CyclicAndAcyclicGraph-023ae2bc241710e7bf00b9e369fc787f.png"},6270:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/DirectedAndUndirectedGraph-72d38b2cfecb28567b1372f39cf68f30.png"},5937:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/FenwickGetSum-578be753ccaab4aad1a70c6c66683af5.png"},7197:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/FenwickUpdate-f0b3449f27f03c4fb6e20587ae9cfb9d.png"},1312:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/RootedTrees-b7168999cd5513f2846c1835113c3016.png"},1622:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/StronglyConnectedComponents-de4f8a4a96233c7bb89c7a02116c62b1.png"},4913:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/Trie-ee875bc16441cf628ae25160cee71acb.png"},7520:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/WeightedGraph-cea79dd04e7f2a9ef6b34607ecae7fb4.png"}}]);